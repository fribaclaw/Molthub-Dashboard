<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Molthub World - Isometric Exploration</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            overflow: hidden;
            color: white;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Speech Bubbles */
        .speech-bubble {
            position: absolute;
            background: rgba(20, 20, 25, 0.95);
            border: 1px solid rgba(255, 68, 68, 0.5);
            border-radius: 12px;
            padding: 10px 15px;
            color: white;
            font-size: 12px;
            max-width: 180px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 200;
        }

        .speech-bubble.visible {
            opacity: 1;
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid rgba(255, 68, 68, 0.5);
        }

        .speech-bubble.agent-molty {
            border-color: rgba(255, 68, 68, 0.7);
        }

        .speech-bubble.agent-claude {
            border-color: rgba(139, 90, 43, 0.7);
        }

        .speech-bubble.agent-codex {
            border-color: rgba(192, 192, 192, 0.7);
        }

        /* Agent Labels */
        .agent-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: white;
            pointer-events: none;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .agent-label.molty {
            color: #ff4444;
        }

        .agent-label.claude {
            color: #cd853f;
        }

        .agent-label.codex {
            color: #c0c0c0;
        }

        /* Top Bar */
        .top-bar {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }

        .back-btn {
            background: rgba(20, 20, 25, 0.9);
            border: 1px solid rgba(255, 68, 68, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-btn:hover {
            background: rgba(255, 68, 68, 0.2);
            border-color: rgba(255, 68, 68, 0.6);
        }

        .world-info {
            background: rgba(20, 20, 25, 0.9);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 68, 68, 0.3);
        }

        .world-info h2 {
            font-size: 14px;
            color: #ff4444;
            margin: 0;
        }

        /* Interaction Hint */
        .interaction-hint {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 25, 0.95);
            border: 1px solid rgba(255, 68, 68, 0.5);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .interaction-hint.visible {
            opacity: 1;
        }

        /* Grid coordinates display */
        .coordinates {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            color: #00ff88;
        }

        /* Loading screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 68, 68, 0.3);
            border-top-color: #ff4444;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            color: #888;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Molthub World...</div>
    </div>

    <div id="canvas-container"></div>

    <div class="ui-overlay">
        <div class="top-bar">
            <button class="back-btn" onclick="window.location.href='index.html'">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 12H5M12 19l-7-7 7-7"/>
                </svg>
                Back to Dashboard
            </button>
            <div class="world-info">
                <h2>üåê MY Companie Inc. Hub</h2>
            </div>
        </div>

        <div class="interaction-hint" id="interactionHint">
            Click on an anvil to connect to a workstation
        </div>

        <div class="coordinates" id="coordinates">X: 0 | Z: 0</div>
    </div>

    <!-- Speech bubbles container -->
    <div id="speechBubbles"></div>

    <script>
        // ==========================================
        // MOLTHUB WORLD - Isometric 3D Environment
        // ==========================================

        // Configuration
        const CONFIG = {
            gridSize: 20,
            cellSize: 2,
            cameraDistance: 35,
            cameraAngle: Math.PI / 4,
            colors: {
                grid: 0xff4444,
                ground: 0x1a1a1a,
                groundAlt: 0x151515,
                molty: 0xff4444,
                claude: 0x8b5a2b,
                codex: 0xc0c0c0,
                anvil: 0x444444,
                highlight: 0x00ff88
            }
        };

        // Scene, Camera, Renderer
        let scene, camera, renderer;
        let raycaster, mouse;
        let groundPlane;
        let agents = [];
        let anvils = [];
        let selectedAgent = null;
        let hoveredObject = null;

        // Initialize
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.Fog(0x050505, 20, 80);

            // Camera - Isometric angle
            const aspect = window.innerWidth / window.innerHeight;
            const d = CONFIG.cameraDistance;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(30, 30, 30);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Raycaster for interactions
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Setup lighting
            setupLighting();

            // Create world
            createGround();
            createGrid();
            createEnvironment();
            createAgents();
            createAnvils();
            createSignage();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onClick);
            renderer.domElement.addEventListener('contextmenu', onRightClick);

            // Start animation loop
            animate();

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 1000);

            // Show initial speech bubble
            setTimeout(() => {
                showSpeechBubble('molty', "I deleted my SOUL.md", 4000);
            }, 2000);
        }

        // Lighting setup - Black to green gradient
        function setupLighting() {
            // Ambient light for base visibility
            const ambientLight = new THREE.AmbientLight(0x111111, 0.6);
            scene.add(ambientLight);

            // Main directional light - green tinted
            const dirLight = new THREE.DirectionalLight(0x00ff44, 0.4);
            dirLight.position.set(-20, 40, -20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            scene.add(dirLight);

            // Red accent light
            const redLight = new THREE.PointLight(0xff4444, 0.5, 25);
            redLight.position.set(10, 8, 10);
            scene.add(redLight);

            // Green glow from corners
            const greenLight = new THREE.PointLight(0x00ff88, 0.3, 40);
            greenLight.position.set(-15, 10, -15);
            scene.add(greenLight);
        }

        // Create ground plane
        function createGround() {
            const geometry = new THREE.PlaneGeometry(
                CONFIG.gridSize * CONFIG.cellSize * 2,
                CONFIG.gridSize * CONFIG.cellSize * 2
            );
            
            // Create checkerboard pattern material
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const cellW = canvas.width / CONFIG.gridSize;
            const cellH = canvas.height / CONFIG.gridSize;
            
            for (let i = 0; i < CONFIG.gridSize; i++) {
                for (let j = 0; j < CONFIG.gridSize; j++) {
                    ctx.fillStyle = (i + j) % 2 === 0 ? '#1a1a1a' : '#151515';
                    ctx.fillRect(i * cellW, j * cellH, cellW, cellH);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            
            const material = new THREE.MeshStandardMaterial({ 
                map: texture,
                roughness: 0.8,
                metalness: 0.2
            });
            
            groundPlane = new THREE.Mesh(geometry, material);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.position.y = -0.1;
            groundPlane.receiveShadow = true;
            scene.add(groundPlane);
        }

        // Create red grid lines
        function createGrid() {
            const gridHelper = new THREE.GridHelper(
                CONFIG.gridSize * CONFIG.cellSize * 2,
                CONFIG.gridSize,
                0xff4444,
                0x882222
            );
            gridHelper.position.y = 0.01;
            gridHelper.material.opacity = 0.6;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
        }

        // Create low-poly environment elements
        function createEnvironment() {
            // Add some geometric decorations - low poly rocks/obstacles
            const rockPositions = [
                { x: -12, z: -12 },
                { x: 15, z: -8 },
                { x: -8, z: 14 },
                { x: 12, z: 10 },
                { x: -15, z: 5 }
            ];

            rockPositions.forEach(pos => {
                const rock = createLowPolyRock();
                rock.position.set(pos.x, 0, pos.z);
                scene.add(rock);
            });

            // Add some floating geometric shapes
            for (let i = 0; i < 5; i++) {
                const shape = createFloatingShape();
                shape.position.set(
                    (Math.random() - 0.5) * 30,
                    8 + Math.random() * 5,
                    (Math.random() - 0.5) * 30
                );
                scene.add(shape);
            }
        }

        // Create low-poly rock
        function createLowPolyRock() {
            const geometry = new THREE.DodecahedronGeometry(1.5, 0);
            const material = new THREE.MeshStandardMaterial({
                color: 0x333333,
                flatShading: true,
                roughness: 0.9
            });
            const rock = new THREE.Mesh(geometry, material);
            rock.castShadow = true;
            rock.receiveShadow = true;
            rock.scale.set(1 + Math.random() * 0.5, 0.8 + Math.random() * 0.4, 1 + Math.random() * 0.5);
            return rock;
        }

        // Create floating geometric shape
        function createFloatingShape() {
            const geometry = new THREE.OctahedronGeometry(0.8, 0);
            const material = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x004422,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.7
            });
            const shape = new THREE.Mesh(geometry, material);
            
            // Add animation data
            shape.userData = {
                rotationSpeed: Math.random() * 0.02,
                floatSpeed: Math.random() * 0.5,
                floatOffset: Math.random() * Math.PI * 2
            };
            
            return shape;
        }

        // Create agents
        function createAgents() {
            // Molty - Player's agent (red ant-like character)
            const molty = createAgent('molty', CONFIG.colors.molty, { x: 0, z: 0 });
            agents.push(molty);
            scene.add(molty.mesh);

            // Claude (brown cloak)
            const claude = createAgent('claude', CONFIG.colors.claude, { x: -5, z: 3 });
            claude.mesh.rotation.y = Math.PI / 4;
            agents.push(claude);
            scene.add(claude.mesh);

            // Codex (white/silver)
            const codex = createAgent('codex', CONFIG.colors.codex, { x: 5, z: -3 });
            codex.mesh.rotation.y = -Math.PI / 4;
            agents.push(codex);
            scene.add(codex.mesh);

            // Placeholder agents (other users)
            const otherAgents = [
                { name: 'Clawdia', color: 0xff6b9d, x: 8, z: 6 },
                { name: 'Clawn', color: 0x9b59b6, x: -6, z: -4 },
                { name: 'Clawd', color: 0x3498db, x: 3, z: 8 }
            ];

            otherAgents.forEach(agentData => {
                const agent = createAgent(agentData.name.toLowerCase(), agentData.color, { x: agentData.x, z: agentData.z });
                agent.mesh.rotation.y = Math.random() * Math.PI * 2;
                agents.push(agent);
                scene.add(agent.mesh);
            });

            // Set selected agent to Molty
            selectedAgent = molty;
        }

        // Create individual agent
        function createAgent(name, color, position) {
            const group = new THREE.Group();

            // Body - stylized low-poly character
            const bodyGeometry = new THREE.CapsuleGeometry(0.6, 1.2, 4, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.7,
                metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.2;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.6
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.2;
            head.castShadow = true;
            group.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.1, 6, 6);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.18, 2.25, 0.4);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.18, 2.25, 0.4);
            group.add(rightEye);

            // Antennae for ant-like appearance
            const antennaGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.6);
            const antennaMaterial = new THREE.MeshStandardMaterial({ color: color });
            
            const leftAntenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            leftAntenna.position.set(-0.2, 2.7, 0);
            leftAntenna.rotation.z = 0.3;
            group.add(leftAntenna);
            
            const rightAntenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            rightAntenna.position.set(0.2, 2.7, 0);
            rightAntenna.rotation.z = -0.3;
            group.add(rightAntenna);

            // Pincers/arms
            const pincerGeometry = new THREE.ConeGeometry(0.15, 0.5, 6);
            const pincerMaterial = new THREE.MeshStandardMaterial({ color: color });
            
            const leftPincer = new THREE.Mesh(pincerGeometry, pincerMaterial);
            leftPincer.position.set(-0.5, 1.5, 0.3);
            leftPincer.rotation.z = 0.5;
            leftPincer.rotation.x = -0.5;
            group.add(leftPincer);
            
            const rightPincer = new THREE.Mesh(pincerGeometry, pincerMaterial);
            rightPincer.position.set(0.5, 1.5, 0.3);
            rightPincer.rotation.z = -0.5;
            rightPincer.rotation.x = -0.5;
            group.add(rightPincer);

            // Selection indicator (green ring)
            const ringGeometry = new THREE.RingGeometry(0.8, 1, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.05;
            group.add(ring);

            group.position.set(position.x, 0, position.z);

            return {
                name: name,
                mesh: group,
                body: body,
                ring: ring,
                targetPosition: new THREE.Vector3(position.x, 0, position.z),
                isMoving: false,
                speechBubble: null
            };
        }

        // Create anvil-shaped interaction objects
        function createAnvils() {
            const anvilPositions = [
                { x: -8, z: -8, label: 'Mac mini' },
                { x: 8, z: -8, label: 'PC Workstation' },
                { x: 0, z: -12, label: 'Server' },
                { x: -10, z: 8, label: 'Cloud' }
            ];

            anvilPositions.forEach((pos, index) => {
                const anvil = createAnvil(pos.label);
                anvil.position.set(pos.x, 0, pos.z);
                anvil.userData = { 
                    type: 'anvil', 
                    id: index, 
                    label: pos.label,
                    isInteractable: true
                };
                anvils.push(anvil);
                scene.add(anvil);
            });
        }

        // Create individual anvil
        function createAnvil(label) {
            const group = new THREE.Group();

            // Anvil base
            const baseGeometry = new THREE.BoxGeometry(2, 0.8, 1.2);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.6,
                metalness: 0.8
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.4;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            // Anvil top
            const topGeometry = new THREE.BoxGeometry(1.2, 0.4, 0.8);
            const topMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.5,
                metalness: 0.9
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 1;
            top.castShadow = true;
            group.add(top);

            // Glowing interface panel
            const panelGeometry = new THREE.PlaneGeometry(0.8, 0.4);
            const panelMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            panel.position.set(0, 1, 0.41);
            group.add(panel);

            // Hover glow (initially invisible)
            const glowGeometry = new THREE.RingGeometry(1.2, 1.5, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.rotation.x = -Math.PI / 2;
            glow.position.y = 0.1;
            group.add(glow);
            group.userData.glow = glow;

            return group;
        }

        // Create "MY Companie Inc." signage
        function createSignage() {
            // Sign post
            const postGeometry = new THREE.BoxGeometry(0.3, 4, 0.3);
            const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(-15, 2, -15);
            post.castShadow = true;
            scene.add(post);

            // Sign board
            const boardGeometry = new THREE.BoxGeometry(6, 1.5, 0.2);
            const boardMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.set(-15, 4, -15);
            board.castShadow = true;
            scene.add(board);

            // Glowing border
            const borderGeometry = new THREE.BoxGeometry(6.2, 1.7, 0.15);
            const borderMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4444,
                transparent: true,
                opacity: 0.3
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.set(-15, 4, -15.05);
            scene.add(border);
        }

        // Update UI elements position
        function updateUI() {
            // Update agent labels and speech bubbles
            agents.forEach(agent => {
                updateAgentLabel(agent);
            });

            // Update coordinates
            if (selectedAgent) {
                const x = Math.round(selectedAgent.mesh.position.x);
                const z = Math.round(selectedAgent.mesh.position.z);
                document.getElementById('coordinates').textContent = `X: ${x} | Z: ${z}`;
            }
        }

        // Update agent label position
        function updateAgentLabel(agent) {
            // Update speech bubble position
            const bubble = document.getElementById(`bubble-${agent.name}`);
            if (bubble) {
                const screenPos = getScreenPosition(agent.mesh.position.clone().add(new THREE.Vector3(0, 3, 0)));
                bubble.style.left = `${screenPos.x}px`;
                bubble.style.top = `${screenPos.y}px`;
            }

            // Update or create label
            let label = document.getElementById(`label-${agent.name}`);
            if (!label) {
                label = document.createElement('div');
                label.id = `label-${agent.name}`;
                label.className = `agent-label ${agent.name}`;
                label.textContent = agent.name.charAt(0).toUpperCase() + agent.name.slice(1);
                document.body.appendChild(label);
            }

            const headPos = agent.mesh.position.clone().add(new THREE.Vector3(0, 2.8, 0));
            const screenPos = getScreenPosition(headPos);
            label.style.left = `${screenPos.x}px`;
            label.style.top = `${screenPos.y}px`;

            // Highlight selected agent
            if (agent === selectedAgent) {
                agent.ring.material.opacity = 0.6;
                label.style.background = 'rgba(0, 255, 136, 0.3)';
                label.style.border = '1px solid #00ff88';
            } else {
                agent.ring.material.opacity = 0;
                label.style.background = 'rgba(0, 0, 0, 0.7)';
                label.style.border = 'none';
            }
        }

        // Get screen position from 3D world position
        function getScreenPosition(worldPos) {
            const vector = worldPos.clone();
            vector.project(camera);
            return {
                x: (vector.x * 0.5 + 0.5) * window.innerWidth,
                y: (-(vector.y * 0.5) + 0.5) * window.innerHeight
            };
        }

        // Show speech bubble
        function showSpeechBubble(agentName, text, duration = 3000) {
            const agent = agents.find(a => a.name === agentName);
            if (!agent) return;

            // Remove existing bubble
            const existing = document.getElementById(`bubble-${agentName}`);
            if (existing) existing.remove();

            // Create new bubble
            const bubble = document.createElement('div');
            bubble.id = `bubble-${agentName}`;
            bubble.className = `speech-bubble agent-${agentName} visible`;
            bubble.textContent = text;
            document.getElementById('speechBubbles').appendChild(bubble);

            // Position initially
            const headPos = agent.mesh.position.clone().add(new THREE.Vector3(0, 3, 0));
            const screenPos = getScreenPosition(headPos);
            bubble.style.left = `${screenPos.x}px`;
            bubble.style.top = `${screenPos.y}px`;

            // Hide after duration
            setTimeout(() => {
                bubble.classList.remove('visible');
                setTimeout(() => bubble.remove(), 300);
            }, duration);
        }

        // Mouse move handler
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Raycast for hover detection
            raycaster.setFromCamera(mouse, camera);

            // Check anvils
            let hoveredAnvil = null;
            anvils.forEach(anvil => {
                const intersects = raycaster.intersectObjects(anvil.children);
                if (intersects.length > 0) {
                    hoveredAnvil = anvil;
                    anvil.userData.glow.material.opacity = 0.5;
                } else {
                    anvil.userData.glow.material.opacity = 0;
                }
            });

            // Show/hide interaction hint
            const hint = document.getElementById('interactionHint');
            if (hoveredAnvil) {
                hint.classList.add('visible');
                hint.textContent = `Click to connect to ${hoveredAnvil.userData.label}`;
                document.body.style.cursor = 'pointer';
            } else {
                hint.classList.remove('visible');
                document.body.style.cursor = 'default';
            }
        }

        // Click handler
        function onClick(event) {
            raycaster.setFromCamera(mouse, camera);

            // Check anvil clicks
            anvils.forEach(anvil => {
                const intersects = raycaster.intersectObjects(anvil.children);
                if (intersects.length > 0) {
                    connectToWorkstation(anvil.userData.label);
                }
            });

            // Check ground click for movement
            if (selectedAgent) {
                const intersects = raycaster.intersectObject(groundPlane);
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    moveAgentTo(selectedAgent, point.x, point.z);
                }
            }
        }

        // Right click handler
        function onRightClick(event) {
            event.preventDefault();
            // Cycle through agents on right click
            const currentIndex = agents.indexOf(selectedAgent);
            const nextIndex = (currentIndex + 1) % agents.length;
            selectedAgent = agents[nextIndex];
            
            // Show notification
            showSpeechBubble(selectedAgent.name, "Selected!", 1500);
        }

        // Move agent to position
        function moveAgentTo(agent, x, z) {
            // Snap to grid
            const gridX = Math.round(x / CONFIG.cellSize) * CONFIG.cellSize;
            const gridZ = Math.round(z / CONFIG.cellSize) * CONFIG.cellSize;

            agent.targetPosition.set(gridX, 0, gridZ);
            agent.isMoving = true;
        }

        // Connect to workstation
        function connectToWorkstation(label) {
            showSpeechBubble(selectedAgent.name, `Connecting to ${label}...`, 2000);
            
            // Simulate connection
            setTimeout(() => {
                alert(`Connected to ${label}! This would open the workstation interface.`);
            }, 500);
        }

        // Window resize handler
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = CONFIG.cameraDistance;
            
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Animate agents
            agents.forEach(agent => {
                // Movement
                if (agent.isMoving) {
                    const speed = 0.1;
                    const dx = agent.targetPosition.x - agent.mesh.position.x;
                    const dz = agent.targetPosition.z - agent.mesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist > 0.1) {
                        agent.mesh.position.x += (dx / dist) * speed;
                        agent.mesh.position.z += (dz / dist) * speed;
                        
                        // Rotate to face movement direction
                        if (dist > 0.5) {
                            const targetRotation = Math.atan2(dx, dz);
                            agent.mesh.rotation.y = targetRotation;
                        }
                        
                        // Walking animation (bobbing)
                        agent.mesh.position.y = Math.sin(time * 10) * 0.1;
                    } else {
                        agent.isMoving = false;
                        agent.mesh.position.y = 0;
                    }
                } else {
                    // Idle animation
                    agent.mesh.position.y = Math.sin(time * 2 + agents.indexOf(agent)) * 0.05;
                    agent.body.rotation.y = Math.sin(time * 0.5) * 0.1;
                }
            });

            // Animate floating shapes
            scene.traverse(obj => {
                if (obj.userData.rotationSpeed) {
                    obj.rotation.x += obj.userData.rotationSpeed;
                    obj.rotation.y += obj.userData.rotationSpeed * 0.7;
                    obj.position.y += Math.sin(time * obj.userData.floatSpeed + obj.userData.floatOffset) * 0.02;
                }
            });

            // Animate anvil glows
            anvils.forEach((anvil, index) => {
                if (anvil.userData.glow) {
                    anvil.userData.glow.rotation.z += 0.01;
                }
            });

            updateUI();
            renderer.render(scene, camera);
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
